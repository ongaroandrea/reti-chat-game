\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url,}
\usepackage{fancyhdr, graphicx}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}

\usepackage[italian]{babel}

\usepackage[italian]{cleveref}
\renewcommand{\headrulewidth}{0pt}
\fancyhead[L]{}
\fancyhead[R]{
	\includegraphics[width=4cm]{img/logocampus.jpg}
}
\pagestyle{plain}
\title{Relazione per \\``Programmazione di Reti'' \\ ChatGame}

\author{Carboni Leonardo - Ongaro Andrea}
\date{\today}


\begin{document}

\maketitle

\tableofcontents
\thispagestyle{fancy}

\chapter{Traccia Scelta}
Sfruttando il principio della CHAT vista a lezione implementate
un’architettura client-server per il supporto di un Multiplayer
Playing Game testuale. \\
I giocatori che accedono alla stanza sono accolti dal Master
(server) che assegna loro un ruolo e propone loro un menu con
tre opzioni, due delle quali celano una domanda mentre la
terza è l’opzione trabocchetto. Se sceglie l’opzione trabocchetto viene eliminato dal gioco e quindi esce dalla chat.
Se seleziona invece una delle domande e risponde
correttamente al quesito acquisisce un punto, in caso contrario
perde un punto.\\
Il gioco ha una durata temporale finita; il giocatore che al
termine del tempo ha acquisito più punti è il vincitore

\chapter{Descrizione Generale}
In questo capitolo esponiamo la nostra interpretazione della traccia scelta tra le tre proposte soffermandoci anche sulle scelte di progettazione più rilevanti.

\subsection{PREPARATIVI}
Dopo aver aperto le connessioni ai client essi saranno liberi di accedere al server e lo stato del gioco verrà posto inizialmente come NOT-STARTED e a tutti gli utenti sarà chiesto di inserire i nomi.\\
Sarà imposto solamente un vincolo nel momento in cui ci si collega al server ovvero l'impossibilità di scegliere un nome uguale a quelli già presenti in gioco.
Per facilitare la scelta verranno mostrati a video tutti i nomi già inseriti all'interno del gioco.
All'interno del server i client verranno quindi identificati tramite i loro indirizzi -- FORSE 
Una volta che l'utente avrà inserito un nome valido verrà creata l'istanza giocatore contenente il nome, un ruolo e impostando lo status del giocatore come non pronto e aggiunto alla lista dei giocatori. \\
\\
Il gioco non può partire solamente in tre casi:
\begin{itemize}
	\item la presenza di un solo giocatore all'interno del gioco, anche se si è dichiarato pronto
	\item non tutti i giocatori si sono dichiarati pronti
	\item il gioco è già partito
\end{itemize}
Una volta che la partita è iniziata nessun giocatore potrà entrare e solamente il giocatore corrente potrà inviare messaggi - se un altro giocatore scriverà un messaggio verrà avvertito che non è il suo turno e il messaggio appena scritto non verrà inoltrato agli altri giocatori.\\

Verranno tenute traccia anche dei turni giocati dove un turno corrisponde alla completa iterazione dei giocatori ancora in gioco.
\subsection{IL GIOCO}
All'inizio del gioco partirà un timer di 10 minuti.
Vengono poi mostrate tre possibili scelte tra le quali il giocatore corrente potrà scegliere. Due di queste saranno giuste e mostreranno una domanda presa casualmente tra quelle inserite nel file "domande.json".\\
Se il giocatore sceglierà la risposta giusta verranno aggiunti al punteggio attuale del giocatore 100 punti moltiplicati per il turno attuale così da ricevere più punti più avanti si va.
Se un giocatore, però, sceglierà la porta sbagliata verrà fatto uscire dal gioco e non concorrerà alla vittoria del gioco, anche se rimarrà all'interno della chat vedendo il proseguimento del gioco.\\
\subsection{FINE GIOCO}
Il gioco terminerà in due casi:
\begin{itemize}
	\item un giocatore rimarrà da solo 
	\item al termine del countdown impostato all'inizio del gioco.\\ In questo caso verranno analizzati tutti i giocatori ancora all'interno del gioco e verrà mostrato il giocatore che ha realizzato più punti
\end{itemize}
Dopo aver mostrato la classifica verranno impostati tutti i giocatori come non pronti e verrà chiesto di giocare un'altra partita. In questa fase potranno entrare anche altri giocatori.

\begin{figure}[h]
\centering{}
\includegraphics{img/analysis.pdf}
\caption{Schema UML dell'analisi del problema, con rappresentate le entità principali ed i rapporti fra loro}
\label{img:analysis}
\end{figure}

\chapter{Strutture dati}
Abbiamo utilizzato alcune delle strutture dati offerte da python preferendo alcune rispetto ad altre.
\subsection{DIZIONARI}
Innanzitutto sono stati utilizzati i dizionari, un tipo built-in, mutabile e non ordinato che contiene elementi formati da una chiave (key) e un valore (value). Una volta che il dizionario è creato è valorizzato con un insieme di coppie <chiave, valore>, si può usare la chiave (che deve essere univoca) per ottenere il valore corrispondente. \\ Proprio per queste caratteristiche che sono stati utilizzati per implementare la memorizzazione degli utenti che accedono al server e per la lettura da file. Un dizionario viene utilizzato per la registrazione dei client in ingresso mentre il secondo per i nomi associati agli indirizzi. Ogni elemento corrisponderà al nome dell'utente che viene identificato da un indirizzo ip.\\
Il terzo e ultimo dizionario verrà creato dal metodo json.load, utilizzato dopo aver importato la libreria interna di python "json".
Questo metodo ha il compito di leggere il file passato in input, analizzare il contenuto JSON e creare un dizionario con i dati.
 
\subsection{LISTE} 
Una lista è una serie ordinata di valori, ognuno identificato da un indice. I valori che fanno parte della lista sono chiamati elementi.
Sono state utilizzate le liste perchè al contrario delle tuple, che contengono oggetti eterogenei tra loro, la lista contiene oggetti tutti omogenei tra loro mentre per quanto riguarda i set sono stati scartati per l'impossibilità di garantire un ordine all'interno cosa molto importante per la realizzazione della logica di gioco.
-- Oltre per questo fine sono state utilizzate per immagazzinare i dizionari con le informazioni delle domande --

\chapter{Threads attivati}
\subsection{GIOCO PRINCIPALE}
All'interno del gioco principale vengono creati dei thread per la gestione del tempo totale di gioco, ovvero 10 minuti e per il tempo di risposta del giocatore. Quest'ultimo thread viene attivato ogni volta che un giocatore deve rispondere ad una domanda e viene fatto per evitare che perda troppo tempo nel rispondere così da togliere l'opportunità di giocare agli altri utenti.

\subsection{SERVER e CLIENT}
SERVER\\
Nel server vengono gestiti due thread. 
Il primo si occupa di accettare le connessioni in entrata che grazie al ciclo while rimangono in attesa per sempre occupandosi di immagazzinare tutti i client arrivati.
Il secondo, invece, ha il compito di gestire i client e proprio in questo che viene contenuta tutta la logica di gioco. Ha come unico parametro il client in modo tale che poter ottenere i messaggi che invia. A seconda del messaggio che invierà l'utente verrà eseguita una diversa azione.
Per far sì che il server non si chiuda subito dopo essere partito, partenza che avviene con l'accettazione delle connessioni, utilizziamo il metodo join che aspetta per il completamento della funzione senza passare alla riga successiva che causerebbe la chiusura del server.\\
\\
Client\\
Per quanto riguarda il client viene utilizzato un unico thread che si occupa di gestire la ricezione dei messaggi andando poi ad aggiungerli alla vista che si occupa di mostrarli, realizzata tramite la libreria tkinter.

\chapter{Indicazioni per la loro esecuzione}
COME FAR PARTIRE IL CLIENT
---------------
COME FAR PARTIRE IL SERVER
---------------

Un giocatore si può dichiarare pronto cliccando il pulsante PRONTO posto a lato del pulsante per inviare i messaggi.
\end{document}
